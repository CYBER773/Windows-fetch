{"name":"WinSysFetch.ps1","type":"code/powershell","content":"<#\n WinSysFetch.ps1 - Fastfetch‑style Windows system summary\n --------------------------------------------------------\n Gathers and displays key hardware / OS facts similar to fastfetch / neofetch:\n   • OS + version + uptime\n   • CPU (model, cores, threads, base/max clocks, generation + suffix parse)\n   • GPU(s) (name, VRAM, driver)\n   • Memory (total, per‑DIMM details: size, type DDR#, speed, manufacturer)\n   • Storage devices (model, size, SSD/HDD/NVMe, bus)\n   • Volumes usage (C:, others)\n   • Network IPv4 addresses\n\n Output: Colorized aligned text block OR JSON (-Json) for scripting.\n\n Usage examples:\n   PS> .\WinSysFetch.ps1\n   PS> .\WinSysFetch.ps1 -NoColor\n   PS> .\WinSysFetch.ps1 -Json | ConvertTo-Json -Depth 4\n\n Requires: PowerShell 5+ (works best in PS7). Some info (Get-PhysicalDisk) needs admin + newer Storage module.\n#>\n\n[CmdletBinding()]\nparam(\n    [switch]$NoColor,\n    [switch]$Json\n)\n\n# --------------------------- Helpers ---------------------------\nfunction Write-Color {\n    param(\n        [string]$Text,\n        [ConsoleColor]$Color = [ConsoleColor]::Gray,\n        [switch]$NoNewline\n    )\n    if ($script:NoColor) {\n        if ($NoNewline) { Write-Host -NoNewline $Text } else { Write-Host $Text }\n    } else {\n        if ($NoNewline) { Write-Host -ForegroundColor $Color -NoNewline $Text } else { Write-Host -ForegroundColor $Color $Text }\n    }\n}\n\n# Human‑readable size\nfunction Format-Bytes {\n    param([UInt64]$Bytes)\n    if ($Bytes -lt 1KB) {return "$Bytes B"}\n    elseif ($Bytes -lt 1MB) {return "{0:N2} KB" -f ($Bytes/1KB)}\n    elseif ($Bytes -lt 1GB) {return "{0:N2} MB" -f ($Bytes/1MB)}\n    elseif ($Bytes -lt 1TB) {return "{0:N2} GB" -f ($Bytes/1GB)}\n    else {return "{0:N2} TB" -f ($Bytes/1TB)}\n}\n\n# Map SMBIOS memory type to DDR label (best‑effort)\n$DDRTypeMap = @{ 20='DDR';21='DDR2';22='DDR2 FB-DIMM';24='DDR3';26='DDR4';27='LPDDR';29='LPDDR2';30='LPDDR3';31='LPDDR4';32='Logical';33='HBM';34='HBM2';35='DDR5';36='LPDDR5' }\nfunction Get-DDRLabel {\n    param($MemObj)\n    $t = $null\n    if ($MemObj.SMBIOSMemoryType -and $MemObj.SMBIOSMemoryType -ne 0) { $t = $MemObj.SMBIOSMemoryType }\n    elseif ($MemObj.MemoryType -and $MemObj.MemoryType -ne 0) { $t = $MemObj.MemoryType }\n    if ($t -and $DDRTypeMap.ContainsKey([int]$t)) { return $DDRTypeMap[[int]$t] }\n    # heuristic from Speed strings\n    if ($MemObj.Speed -ge 6400) {return 'DDR5?'}\n    elseif ($MemObj.Speed -ge 3200) {return 'DDR4?'}\n    elseif ($MemObj.Speed -ge 1600) {return 'DDR3?'}\n    return 'Unknown'\n}\n\n# Parse Intel generation + suffix from CPU name string\nfunction Parse-IntelCPUName {\n    param([string]$Name)\n    $out = [ordered]@{Generation=$null; Suffix=$null}\n    if ($Name -match '(Core\\s+i[3579]|Core\\s+Ultra|Core\TM\2)') {\n        # capture model block like i7-12700H, i5-8250U, i9-13900K, etc.\n        if ($Name -match '([iI][3579]|Ultra)\s*-?\s*([0-9]{3,5})([A-Za-z]{0,3})') {\n            $digits = $Matches[2]; $suf = $Matches[3]\n            # 5 digits => 10th gen+ (first 2 digits); 4 digits => first digit\n            if ($digits.Length -ge 5) {$gen = [int]$digits.Substring(0,2)} else {$gen = [int]$digits.Substring(0,1)}\n            $out.Generation = $gen\n            if ($suf) { $out.Suffix = $suf.ToUpper() }\n        }\n    }\n    return $out\n}\n\n# Parse AMD Ryzen series & guess architecture gen\n$AMDZenMap = @{ '1'='Zen/Zen+'; '2'='Zen 2'; '3'='Zen 2/3 Mobile'; '4'='Zen 2 (Mobile)'; '5'='Zen 3'; '6'='Zen 3+/4 Mobile'; '7'='Zen 4'; '8'='Zen 5 (Est)'}\nfunction Parse-AMDCPUName {\n    param([string]$Name)\n    $out = [ordered]@{Series=$null; ArchGuess=$null}\n    if ($Name -match 'Ryzen\s*[\w\-]\s([1-9][0-9]{3})') {\n        $series = $Matches[1]\n        $out.Series = $series\n        $lead = $series.Substring(0,1)\n        if ($AMDZenMap.ContainsKey($lead)) { $out.ArchGuess = $AMDZenMap[$lead] }\n    }\n    return $out\n}\n\n# ASCII Windows logo (11‑ish) for left column art\n$WinArt = @(\n    "                    ",\n    "  ____ _                 _            ",\n    " / | | ___  _   _  __| | ___  ___  ",\n    "| |  | |/ _ \\| | | |/ ` |/ _ \\/ _ \",\n    "| || | | () | || | (| |  __/  __/",\n    " \\||\\/ \\,_|\\,|\\|\\|",\n    "                    "\n)\n\n# gather OS ------------------------------------------------------\n$os = Get-CimInstance Win32_OperatingSystem\n$cs = Get-CimInstance Win32_ComputerSystem\n$boot = [Management.ManagementDateTimeConverter]::ToDateTime($os.LastBootUpTime)\n$uptimeSpan = (Get-Date) - $boot\n$uptimeFmt = if ($uptimeSpan.TotalDays -ge 1) {"{0}d {1}h" -f [int]$uptimeSpan.TotalDays, $uptimeSpan.Hours} elseif ($uptimeSpan.TotalHours -ge 1) {"{0}h {1}m" -f [int]$uptimeSpan.TotalHours, $uptimeSpan.Minutes} else {"{0}m" -f [int]$uptimeSpan.TotalMinutes}\n\n# CPU -------------------------------------------------------------\n$cpu = Get-CimInstance Win32_Processor | Select-Object -First 1\n$cpuName = $cpu.Name.Trim()\n$cpuVendor = $cpu.Manufacturer\n$cpuCores = $cpu.NumberOfCores\n$cpuThreads = $cpu.NumberOfLogicalProcessors\n$cpuBaseMHz = $cpu.MaxClockSpeed   # reported in MHz\n$cpuBaseGHz = [math]::Round($cpuBaseMHz/1000,2)\n$cpuExtra = $null\nif ($cpuVendor -match 'Intel') {\n    $parsed = Parse-IntelCPUName $cpuName\n    $cpuExtra = "Gen {0}{1}" -f $parsed.Generation, (if($parsed.Suffix){" ($($parsed.Suffix))"}else{''})\n}\nelseif ($cpuVendor -match 'AMD') {\n    $parsed = Parse-AMDCPUName $cpuName\n    if ($parsed.Series) {\n        $cpuExtra = "Series $($parsed.Series) ($($parsed.ArchGuess))"\n    }\n}\n\n# GPU(s) ----------------------------------------------------------\n$gpus = Get-CimInstance Win32_VideoController | Sort-Object Name\n$gpuInfo = foreach ($g in $gpus) {\n    [pscustomobject]@{\n        Name=$g.Name.Trim()\n        VRAM_GB = [math]::Round(($g.AdapterRAM/1GB),2)\n        DriverVersion=$g.DriverVersion\n        DriverDate=([Management.ManagementDateTimeConverter]::ToDateTime($g.DriverDate)).ToString('yyyy-MM-dd')\n    }\n}\n\n# Memory ----------------------------------------------------------\n$memMods = Get-CimInstance Win32_PhysicalMemory\n$memTotalBytes = ($memMods | Measure-Object -Property Capacity -Sum).Sum\n$memTotalGB = [math]::Round($memTotalBytes/1GB,2)\n$memModObjs = foreach($m in $memMods){\n    [pscustomobject]@{\n        Slot=$m.DeviceLocator\n        SizeGB=[math]::Round($m.Capacity/1GB,2)\n        Type=(Get-DDRLabel $m)\n        SpeedMHz=$m.Speed\n        Manufacturer=$m.Manufacturer\n        PartNumber=$m.PartNumber.Trim()\n    }\n}\n\n# Storage ---------------------------------------------------------\n# Try modern Storage cmdlets first\n$physicalDisks = @()\ntry {\n    $physicalDisks = Get-PhysicalDisk -ErrorAction Stop | ForEach-Object {\n        [pscustomobject]@{\n            FriendlyName=$.FriendlyName\n            SizeGB=[math]::Round($.Size/1GB,2)\n            MediaType=if ($.MediaType -ne 'Unspecified') {$.MediaType} else {if($.BusType -eq 'NVMe'){ 'SSD' } else {'Unknown'}}\n            BusType=$.BusType\n            Serial=$.SerialNumber\n        }\n    }\n} catch {\n    # fall back to Win32_DiskDrive\n    $wmiDisks = Get-CimInstance Win32_DiskDrive\n    $physicalDisks = $wmiDisks | ForEach-Object {\n        $rot = $.MediaType\n        $isSSD = if ($rot -match 'Solid State' -or $.Model -match 'SSD' -or $.Model -match 'NVMe') { 'SSD' } else { 'HDD?' }\n        [pscustomobject]@{\n            FriendlyName=$.Model\n            SizeGB=[math]::Round($.Size/1GB,2)\n            MediaType=$isSSD\n            BusType=$.InterfaceType\n            Serial=$.SerialNumber\n        }\n    }\n}\n\n# Volumes usage (all fixed)\n$volumes = Get-CimInstance Win32_LogicalDisk -Filter "DriveType=3" | ForEach-Object {\n    [pscustomobject]@{\n        Drive=$.DeviceID\n        UsedGB=[math]::Round(($.Size - $.FreeSpace)/1GB,2)\n        TotalGB=[math]::Round($.Size/1GB,2)\n        FS=$.FileSystem\n    }\n}\n\n# Network IPv4 addresses (up, not loopback)\n$netIPs = Get-NetIPAddress -AddressFamily IPv4 -PrefixOrigin Manual, Dhcp -ErrorAction SilentlyContinue | Where-Object {$.IPAddress -notlike '169.254*' -and $.InterfaceAlias -notmatch 'Loopback'} | ForEach-Object {\n    "{0} ({1})" -f $.IPAddress,$_.InterfaceAlias\n}\n\n# Assemble object -------------------------------------------------\n$result = [pscustomobject]@{\n    ComputerName=$env:COMPUTERNAME\n    User=$env:USERNAME\n    OS=$os.Caption.Trim()\n    OSVersion=$os.Version\n    OSArch=$os.OSArchitecture\n    Uptime=$uptimeFmt\n    LastBoot=$boot\n    CPU=[pscustomobject]@{\n        Name=$cpuName\n        Vendor=$cpuVendor\n        Cores=$cpuCores\n        Threads=$cpuThreads\n        BaseGHz=$cpuBaseGHz\n        ExtraInfo=$cpuExtra\n    }\n    GPU=$gpuInfo\n    Memory=[pscustomobject]@{\n        TotalGB=$memTotalGB\n        Modules=$memModObjs\n    }\n    Storage=$physicalDisks\n    Volumes=$volumes\n    NetworkIPs=$netIPs\n}\n\nif ($Json) {\n    $result # let caller pipe to ConvertTo-Json\n    return\n}\n\n# --------------------------- Pretty Print ---------------------------\n$script:NoColor = $NoColor.IsPresent\n\n# Build right‑side lines\n$lines = @()\n$lines += "${env:USERNAME}@${env:COMPUTERNAME}"\n$lines += ''.PadRight(40,'-')\n$lines += "OS:        $($result.OS) $($result.OSArch)"\n$lines += "Version:   $($result.OSVersion)"\n$lines += "Uptime:    $($result.Uptime)"\n$lines += "Boot:      $($result.LastBoot.ToString('yyyy-MM-dd HH:mm'))"\n$lines += "CPU:       $cpuName"\n$lines += "           Cores:$cpuCores  Threads:$cpuThreads  Base:$cpuBaseGHz GHz"\nif ($cpuExtra) { $lines += "           $cpuExtra" }\nforeach($gi in $gpuInfo){ $lines += "GPU:       $($gi.Name) [$($gi.VRAM_GB) GB] drv $($gi.DriverVersion)" }\n$lines += "Memory:    $memTotalGB GB installed in $($memModObjs.Count) slot(s)"\nforeach($mm in $memModObjs){ $lines += "           $($mm.Slot): $($mm.SizeGB)GB $($mm.Type) @$($mm.SpeedMHz)MHz" }\n$lines += "Storage:   $($physicalDisks.Count) disk(s)"\nforeach($pd in $physicalDisks){ $lines += "           $($pd.FriendlyName) $($pd.SizeGB)GB $($pd.MediaType) ($($pd.BusType))" }\n$lines += "Volumes:"; foreach($v in $volumes){ $lines += "           $($v.Drive) $($v.UsedGB)/$($v.TotalGB)GB $($v.FS)" }\nif ($netIPs.Count -gt 0){ $lines += "IP(s):     $($netIPs -join ', ')" }\n\n# Determine max lines to align with art\n$maxLines = [math]::Max($WinArt.Count, $lines.Count)\n$artPadded = @(); $infoPadded=@()\nfor($i=0;$i -lt $maxLines;$i++){\n    $artPadded += ($WinArt[$i]  ) 2>$null\n    $infoPadded+= ($lines[$i]   ) 2>$null\n}\n\n# Print side‑by‑side\n$colPad = ($WinArt | Measure-Object -Property Length -Maximum).Maximum + 2\nfor($i=0;$i -lt $maxLines;$i++){\n    $a = if($i -lt $WinArt.Count){$WinArt[$i]}else{''}\n    $b = if($i -lt $lines.Count){$lines[$i]}else{''}\n    $pad = $colPad - $a.Length; if($pad -lt 1){$pad=1}\n    if ($NoColor) {\n        Write-Host ($a + (' ' * $pad) + $b)\n    } else {\n        # color art cyan, labels greenish\n        Write-Host -NoNewline -ForegroundColor Cyan $a\n        Write-Host -NoNewline (' ' * $pad)\n        Write-Host $b\n    }\n}\n\n# simple color test bar\nif (-not $NoColor) {\n    Write-Color "\nColor Test: " Cyan -NoNewline\n    foreach($c in [enum]::GetValues([ConsoleColor])){ Write-Host -NoNewline -ForegroundColor $c '■' }\n    Write-Host\n}\n"}

Set-ExecutionPolicy RemoteSigned -Scope CurrentUser

.\WinSysFetch.ps1
